<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>energyscapeExample</title>
<meta name="generator" content="MATLAB 24.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-09-30">
<meta name="DC.source" content="energyscapeExample.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Setup scene and sensor</a>
</li>
<li>
<a href="#2">Setup Energyscape</a>
</li>
<li>
<a href="#3">Generate microphone data</a>
</li>
<li>
<a href="#4">Generate energyscape</a>
</li>
<li>
<a href="#5">Plot energyscape</a>
</li>
<li>
<a href="#6">Helper functions</a>
</li>
</ul>
</div>
<h2 id="1">Setup scene and sensor</h2>
<pre class="codeinput">structScene = struct();
structScene.targetAzimuth = [0  -45  45  20  -20  70];
structScene.targetElevation = [0  0    0   0   0    0];
structScene.targetRange    = [2  1.5  1.8 2.5 2.5  3.0];
structScene.targetStrength = [1  1    1   1   1    1  ];
structScene.speedOfSound = 343;

structSensor = struct();
structSensor.sampleRate = 450e3;
structSensor.emissionSignal = fm_sweep(80e3, 20e3, structSensor.sampleRate, 2, 1, 10);
structSensor.coordinatesEmitter = [0 0 0.05];
structSensor.numSamplesSensor = 15000;
structSensor.coordinatesMicrophones = [0 -0.0384 0.0151; 0 -0.0232 0.0101; 0 -0.0121 0.0164; 0 -0.0046 0.0153; <span class="keyword">...</span>
                                       0 -0.0367 0.0054; 0 -0.0144 0.0061; 0 0.0054 0.0011; 0 0.0273 -0.0027; <span class="keyword">...</span>
                                       0 -0.0387 0.0001; 0 -0.0281 0.0002; 0 -0.0094 -0.0013; 0 -0.0060 -0.0000; <span class="keyword">...</span>
                                       0 -0.0357 -0.0117; 0 -0.0318 -0.0112; 0 -0.0286 -0.0166; 0 0.0029 -0.0086; <span class="keyword">...</span>
                                       0 -0.0011 0.0178; 0 0.0067 0.0115; 0 0.0103 0.0144; 0 0.0172 0.0140; <span class="keyword">...</span>
                                       0 0.0384 0.0022; 0 0.0283 0.0162; 0 0.0354 0.0125; 0 0.0373 0.0150; <span class="keyword">...</span>
                                       0 -0.0084 -0.0047; 0 0.0107 -0.0111; 0 0.0189 -0.0166; 0 0.0363 -0.0101; <span class="keyword">...</span>
                                       0 0.0057 -0.0224; 0 -0.0036 -0.0223; 0 0.0315 -0.0161; 0 0.0083 -0.0178];
</pre>
<h2 id="2">Setup Energyscape</h2>
<pre class="codeinput">structEnergyscapeGeneration = struct();
structEnergyscapeGeneration.azimuthResolution = 1;
structEnergyscapeGeneration.lowpassFreq = 5e3;
structEnergyscapeGeneration.doEnvelope = 1;
structEnergyscapeGeneration.decimationFactor = 10;
structEnergyscapeGeneration.matchedFilterMethod = <span class="string">'Normal'</span>;
structEnergyscapeGeneration.matchedFilterFreq = [20e3 80e3];
structEnergyscapeGeneration.doMatchedFilter = 1;
structEnergyscapeGeneration.methodImaging = <span class="string">'DMAS3'</span>;
structEnergyscapeGeneration.coherenceType = <span class="string">'CF'</span>;
structEnergyscapeGeneration.methodProcessing = <span class="string">'mexcuda'</span>;
structEnergyscapeGeneration.sizeFactor = 1.5;
structEnergyscapeGeneration.filterSize = [101, 7];
structEnergyscapeGeneration.dbCut = -60;
structEnergyscapeGeneration.dbMax = 70;
structEnergyscapeGeneration.minRange = 0.5;
structEnergyscapeGeneration.maxRange = 3.5;
structEnergyscapeGeneration.tanhFactor = 1;
</pre>
<h2 id="3">Generate microphone data</h2>
<pre class="codeinput">dataMicrophones = simulateMicrophoneData(structScene, structSensor);
dataMicrophones = dataMicrophones + 0.1 * randn(size(dataMicrophones));
</pre>
<h2 id="4">Generate energyscape</h2>
<pre class="codeinput">structEnergyscape = clait.generate2DEnergyscape(dataMicrophones, structSensor, structEnergyscapeGeneration);
</pre>
<h2 id="5">Plot energyscape</h2>
<pre class="codeinput">colorMapSize = 1024;
gridColor = [0.5 0.5 0.5];
rangeSpacing = 0.5;
azimuthSpacing = 15;
cmap = jet(1024);

figure;
[energyscapePlotHandle, energyscapeColorBarHandle] = clait.plot2DEnergyscape(structEnergyscape, colorMapSize, cmap, gridColor, rangeSpacing, azimuthSpacing);
drawnow;
title(<span class="string">"Energyscape"</span>)
</pre>
<img vspace="5" hspace="5" src="energyscapeExample_01.png" alt=""> <h2 id="6">Helper functions</h2>
<pre class="codeinput">
<span class="keyword">function</span> dataMicrophonesOut = simulateMicrophoneData( structScene, structSensor )
<span class="comment">%SIMULATEMICROPHONEDATA Simulates microphone data from point targets in a scene.</span>
<span class="comment">%</span>
<span class="comment">%   dataMicrophonesOut = SIMULATEMICROPHONEDATA(structScene, structSensor)</span>
<span class="comment">%   generates a time-domain signal for each microphone by simulating the</span>
<span class="comment">%   reflection of an emitted signal from a set of point targets. The simulation</span>
<span class="comment">%   accounts for the time-of-flight from the emitter to each target and then</span>
<span class="comment">%   to each microphone.</span>
<span class="comment">%</span>
<span class="comment">%   By Cosys-Lab, University of Antwerp</span>
<span class="comment">%   Contributors: Jan Steckel</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS:</span>
<span class="comment">%   -----------------------------------------------------------------------</span>
<span class="comment">%   structScene      : Structure containing scene and target properties. (Mandatory)</span>
<span class="comment">%       .targetAzimuth      : Azimuth angles of point targets. [numTargets x 1] (deg)</span>
<span class="comment">%       .targetElevation    : Elevation angles of point targets. [numTargets x 1] (deg)</span>
<span class="comment">%       .targetRange        : Range (distance) to each point target. [numTargets x 1] (m)</span>
<span class="comment">%       .speedOfSound       : Speed of sound in the medium. [1 x 1] (m/s)</span>
<span class="comment">%       .targetStrength     : Amplitude of the reflection from each target. [numTargets x 1]</span>
<span class="comment">%</span>
<span class="comment">%   structSensor     : Structure containing sensor array setup and signal characteristics. (Mandatory)</span>
<span class="comment">%       .coordinatesEmitter     : Position of the sound source. [1 x 3] (m)</span>
<span class="comment">%       .coordinatesMicrophones : Positions of the microphone array elements. [numMics x 3] (m)</span>
<span class="comment">%       .numSamplesSensor       : Total number of samples to simulate. [1 x 1]</span>
<span class="comment">%       .sampleRate             : ADC sampling frequency. [1 x 1] (Hz)</span>
<span class="comment">%       .emissionSignal         : The transmitted signal. [numSamplesBase x 1]</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS:</span>
<span class="comment">%   -----------------------------------------------------------------------</span>
<span class="comment">%   dataMicrophonesOut : The simulated microphone data.</span>
<span class="comment">%                        Dimensions: [numSamplesSensor x numMics].</span>
<span class="comment">%</span>
<span class="comment">%   NOTES:</span>
<span class="comment">%   - The function models reflections as simple time-of-flight delays and amplitude scaling.</span>
<span class="comment">%   - The final output is the convolution of the time-of-flight impulse response with the emission signal.</span>

    [ pointsX, pointsY, pointsZ ] = sph2cart( deg2rad( structScene.targetAzimuth ), deg2rad( structScene.targetElevation ), structScene.targetRange  );
    targetsCartesian = [ pointsX ;pointsY ;pointsZ ]';

    numTargets = length( structScene.targetAzimuth );
    numChannels = size( structSensor.coordinatesMicrophones, 1 );

    dataMicrophones = zeros( structSensor.numSamplesSensor, numChannels );
    <span class="keyword">for</span> cntTarget = 1 : numTargets
        rangesToTarget = sqrt( sum(( structSensor.coordinatesEmitter - targetsCartesian( cntTarget, : ) ).^2, 2 ) );
        rangesFromTarget = sqrt( sum(( structSensor.coordinatesMicrophones - targetsCartesian( cntTarget, : ) ).^2, 2 ) );
        totalRanges = rangesToTarget + rangesFromTarget;
        totalTimeInSamples = round( totalRanges / structScene.speedOfSound *  structSensor.sampleRate );

        <span class="comment">% rows = totalTimeInSamples(:);        % arrival times</span>
        <span class="comment">% cols = (1:numChannels)';             % channel indices</span>
        <span class="comment">% idx  = sub2ind(size(dataMicrophones), rows, cols);</span>

        <span class="keyword">for</span> cntChannel = 1 : numChannels
            curSample = totalTimeInSamples( cntChannel );
            dataMicrophones( curSample, cntChannel ) = dataMicrophones( curSample, cntChannel ) + structScene.targetStrength( cntTarget );
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    dataMicrophonesOut = zeros( size( dataMicrophones ) );
    <span class="keyword">for</span> cntChannel = 1 : numChannels
        dataMicrophonesOut( :, cntChannel ) = dataMicrophones( :, cntChannel ) + conv( dataMicrophones( :, cntChannel ), structSensor.emissionSignal, <span class="string">'same'</span> );
    <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> sig=fm_sweep(f_start,f_end,fs,duration, amplitude, winprct)
<span class="comment">%FM_SWEEP Generates a hyperbolic FM sweep signal with Hanning windowing.</span>
<span class="comment">%</span>
<span class="comment">%   sig = FM_SWEEP(f_start, f_end, fs, duration, amplitude, winprct) generates</span>
<span class="comment">%   a frequency-modulated (FM) sweep signal, often used as a bat-like call.</span>
<span class="comment">%   The frequency changes hyperbolically from a start frequency to an end</span>
<span class="comment">%   frequency over a specified duration. The signal is then windowed with a</span>
<span class="comment">%   Hanning window at its start and end to prevent spectral leakage.</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS:</span>
<span class="comment">%   -----------------------------------------------------------------------</span>
<span class="comment">%   f_start     : Start frequency of the sweep. [1 x 1] (Hz)</span>
<span class="comment">%</span>
<span class="comment">%   f_end       : End frequency of the sweep. [1 x 1] (Hz)</span>
<span class="comment">%</span>
<span class="comment">%   fs          : Sampling frequency. [1 x 1] (Hz)</span>
<span class="comment">%</span>
<span class="comment">%   duration    : Duration of the sweep. [1 x 1] (ms)</span>
<span class="comment">%</span>
<span class="comment">%   amplitude   : Amplitude of the generated signal. [1 x 1]</span>
<span class="comment">%</span>
<span class="comment">%   winprct     : Percentage of the signal duration to be covered by the</span>
<span class="comment">%                 Hanning window at the start and end of the signal. [1 x 1] (%)</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS:</span>
<span class="comment">%   -----------------------------------------------------------------------</span>
<span class="comment">%   sig         : The generated FM sweep signal vector. [nSamples x 1]</span>
<span class="comment">%</span>
<span class="comment">%   NOTES:</span>
<span class="comment">%   - The frequency modulation is linear with respect to the period (1/f).</span>
<span class="comment">%   - The `duration` input is in milliseconds and is converted to seconds internally.</span>
<span class="comment">%   - The total length of the Hanning window is `2*winprct/100` of the signal length.</span>

    <span class="comment">% The time scale is in milliseconds, convert to seconds</span>
    ms = 10^-3;
    duration = duration * ms;

    <span class="comment">% Generate time vector</span>
    t = 0:1/fs:duration;

    <span class="comment">% Generate the frequency modulation vector (linear with the period)</span>
    ft = 1./(1/f_start + t * (1/f_end - 1/f_start) / duration);

    <span class="comment">% Generate the FM sweep signal</span>
    sig = amplitude * (sin(2*pi*(duration/(1/f_end-1/f_start)) * (log(1/f_start+t*(1/f_end-1/f_start)/duration) - log(1/f_start))));

    <span class="comment">% Apply Hanning window to the start and end of the signal</span>
    length_win = round(length(sig)*2*winprct/100);
    window_short = hanning(length_win);
    window_on = window_short(1:ceil(length_win/2));
    window_off = window_short(ceil(length_win/2) + 1 : end);
    window = ones(1,length(sig));
    window(1:length(window_on)) = window_on;
    window(end-length(window_off) + 1 : end) = window_off;

    sig = sig .* window;
<span class="keyword">end</span>

<span class="keyword">function</span> [mat_out] = normLog(mat_in,threshDB)
<span class="comment">%NORMLOG Normalizes a matrix and converts it to a logarithmic (dB) scale.</span>
<span class="comment">%</span>
<span class="comment">%   [mat_out] = NORMLOG(mat_in, threshDB) normalizes the input matrix `mat_in`</span>
<span class="comment">%   to its global maximum, clips negative values to zero, and then converts</span>
<span class="comment">%   the result to a logarithmic scale in decibels (dB), applying a threshold</span>
<span class="comment">%   to prevent log(0) errors.</span>
<span class="comment">%</span>
<span class="comment">%   By Cosys-Lab, University of Antwerp</span>
<span class="comment">%   Contributors: Jan Steckel</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS:</span>
<span class="comment">%   -----------------------------------------------------------------------</span>
<span class="comment">%   mat_in      : The input matrix or array of any dimension.</span>
<span class="comment">%</span>
<span class="comment">%   threshDB    : A threshold value in decibels (dB). Values below this</span>
<span class="comment">%                 threshold (relative to the maximum) will be clamped to</span>
<span class="comment">%                 this value in the output. [1 x 1] (dB)</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS:</span>
<span class="comment">%   -----------------------------------------------------------------------</span>
<span class="comment">%   mat_out     : The normalized, thresholded, and log-scaled output matrix.</span>
<span class="comment">%                 Dimensions are the same as `mat_in`.</span>
<span class="comment">%</span>
<span class="comment">%   NOTES:</span>
<span class="comment">%   - The function normalizes the input matrix by dividing by its global maximum value.</span>
<span class="comment">%   - The `threshDB` value is converted to a linear scale and added to the</span>
<span class="comment">%     matrix before the `log10` operation to handle values close to zero.</span>
<span class="comment">%   - Negative values in the input matrix are clipped to zero before log-scaling.</span>
<span class="comment">%</span>

    thresh = 10^(threshDB/20);
    mat_out = mat_in / max(max(max(max(mat_in))));
    mat_out( mat_out &lt; 0 ) = 0;
    mat_out = 20*log10( mat_out + thresh);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Setup scene and sensor

structScene = struct();
structScene.targetAzimuth = [0  -45  45  20  -20  70];
structScene.targetElevation = [0  0    0   0   0    0];
structScene.targetRange    = [2  1.5  1.8 2.5 2.5  3.0];
structScene.targetStrength = [1  1    1   1   1    1  ];
structScene.speedOfSound = 343;

structSensor = struct();
structSensor.sampleRate = 450e3;
structSensor.emissionSignal = fm_sweep(80e3, 20e3, structSensor.sampleRate, 2, 1, 10);
structSensor.coordinatesEmitter = [0 0 0.05];
structSensor.numSamplesSensor = 15000;
structSensor.coordinatesMicrophones = [0 -0.0384 0.0151; 0 -0.0232 0.0101; 0 -0.0121 0.0164; 0 -0.0046 0.0153; ...
                                       0 -0.0367 0.0054; 0 -0.0144 0.0061; 0 0.0054 0.0011; 0 0.0273 -0.0027; ...
                                       0 -0.0387 0.0001; 0 -0.0281 0.0002; 0 -0.0094 -0.0013; 0 -0.0060 -0.0000; ...
                                       0 -0.0357 -0.0117; 0 -0.0318 -0.0112; 0 -0.0286 -0.0166; 0 0.0029 -0.0086; ...
                                       0 -0.0011 0.0178; 0 0.0067 0.0115; 0 0.0103 0.0144; 0 0.0172 0.0140; ...
                                       0 0.0384 0.0022; 0 0.0283 0.0162; 0 0.0354 0.0125; 0 0.0373 0.0150; ...
                                       0 -0.0084 -0.0047; 0 0.0107 -0.0111; 0 0.0189 -0.0166; 0 0.0363 -0.0101; ...
                                       0 0.0057 -0.0224; 0 -0.0036 -0.0223; 0 0.0315 -0.0161; 0 0.0083 -0.0178];
    
%% Setup Energyscape

structEnergyscapeGeneration = struct();
structEnergyscapeGeneration.azimuthResolution = 1;
structEnergyscapeGeneration.lowpassFreq = 5e3;
structEnergyscapeGeneration.doEnvelope = 1;
structEnergyscapeGeneration.decimationFactor = 10;
structEnergyscapeGeneration.matchedFilterMethod = 'Normal';
structEnergyscapeGeneration.matchedFilterFreq = [20e3 80e3];
structEnergyscapeGeneration.doMatchedFilter = 1;
structEnergyscapeGeneration.methodImaging = 'DMAS3';
structEnergyscapeGeneration.coherenceType = 'CF';
structEnergyscapeGeneration.methodProcessing = 'mexcuda'; 
structEnergyscapeGeneration.sizeFactor = 1.5;    
structEnergyscapeGeneration.filterSize = [101, 7];
structEnergyscapeGeneration.dbCut = -60;
structEnergyscapeGeneration.dbMax = 70;
structEnergyscapeGeneration.minRange = 0.5;
structEnergyscapeGeneration.maxRange = 3.5;
structEnergyscapeGeneration.tanhFactor = 1;
    
%% Generate microphone data

dataMicrophones = simulateMicrophoneData(structScene, structSensor);
dataMicrophones = dataMicrophones + 0.1 * randn(size(dataMicrophones));

%% Generate energyscape

structEnergyscape = clait.generate2DEnergyscape(dataMicrophones, structSensor, structEnergyscapeGeneration);

%% Plot energyscape

colorMapSize = 1024;
gridColor = [0.5 0.5 0.5];
rangeSpacing = 0.5;
azimuthSpacing = 15;
cmap = jet(1024);

figure;
[energyscapePlotHandle, energyscapeColorBarHandle] = clait.plot2DEnergyscape(structEnergyscape, colorMapSize, cmap, gridColor, rangeSpacing, azimuthSpacing);
drawnow;
title("Energyscape")

%% Helper functions

function dataMicrophonesOut = simulateMicrophoneData( structScene, structSensor )
%SIMULATEMICROPHONEDATA Simulates microphone data from point targets in a scene.
%
%   dataMicrophonesOut = SIMULATEMICROPHONEDATA(structScene, structSensor) 
%   generates a time-domain signal for each microphone by simulating the 
%   reflection of an emitted signal from a set of point targets. The simulation 
%   accounts for the time-of-flight from the emitter to each target and then 
%   to each microphone.
%
%   By Cosys-Lab, University of Antwerp
%   Contributors: Jan Steckel
%
%   INPUTS:
%   REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%   structScene      : Structure containing scene and target properties. (Mandatory)
%       .targetAzimuth      : Azimuth angles of point targets. [numTargets x 1] (deg)
%       .targetElevation    : Elevation angles of point targets. [numTargets x 1] (deg)
%       .targetRange        : Range (distance) to each point target. [numTargets x 1] (m)
%       .speedOfSound       : Speed of sound in the medium. [1 x 1] (m/s)
%       .targetStrength     : Amplitude of the reflection from each target. [numTargets x 1]
%
%   structSensor     : Structure containing sensor array setup and signal characteristics. (Mandatory)
%       .coordinatesEmitter     : Position of the sound source. [1 x 3] (m)
%       .coordinatesMicrophones : Positions of the microphone array elements. [numMics x 3] (m)
%       .numSamplesSensor       : Total number of samples to simulate. [1 x 1]
%       .sampleRate             : ADC sampling frequency. [1 x 1] (Hz)
%       .emissionSignal         : The transmitted signal. [numSamplesBase x 1]
%
%   OUTPUTS:
%   REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%   dataMicrophonesOut : The simulated microphone data.
%                        Dimensions: [numSamplesSensor x numMics].
%
%   NOTES:
%   - The function models reflections as simple time-of-flight delays and amplitude scaling.
%   - The final output is the convolution of the time-of-flight impulse response with the emission signal.
  
    [ pointsX, pointsY, pointsZ ] = sph2cart( deg2rad( structScene.targetAzimuth ), deg2rad( structScene.targetElevation ), structScene.targetRange  );
    targetsCartesian = [ pointsX ;pointsY ;pointsZ ]';
    
    numTargets = length( structScene.targetAzimuth );
    numChannels = size( structSensor.coordinatesMicrophones, 1 );
    
    dataMicrophones = zeros( structSensor.numSamplesSensor, numChannels );  
    for cntTarget = 1 : numTargets
        rangesToTarget = sqrt( sum(( structSensor.coordinatesEmitter - targetsCartesian( cntTarget, : ) ).^2, 2 ) );
        rangesFromTarget = sqrt( sum(( structSensor.coordinatesMicrophones - targetsCartesian( cntTarget, : ) ).^2, 2 ) );
        totalRanges = rangesToTarget + rangesFromTarget;
        totalTimeInSamples = round( totalRanges / structScene.speedOfSound *  structSensor.sampleRate );
    
        % rows = totalTimeInSamples(:);        % arrival times
        % cols = (1:numChannels)';             % channel indices
        % idx  = sub2ind(size(dataMicrophones), rows, cols);
    
        for cntChannel = 1 : numChannels
            curSample = totalTimeInSamples( cntChannel );
            dataMicrophones( curSample, cntChannel ) = dataMicrophones( curSample, cntChannel ) + structScene.targetStrength( cntTarget );
        end
    end
    dataMicrophonesOut = zeros( size( dataMicrophones ) );
    for cntChannel = 1 : numChannels
        dataMicrophonesOut( :, cntChannel ) = dataMicrophones( :, cntChannel ) + conv( dataMicrophones( :, cntChannel ), structSensor.emissionSignal, 'same' );
    end

end

function sig=fm_sweep(f_start,f_end,fs,duration, amplitude, winprct)
%FM_SWEEP Generates a hyperbolic FM sweep signal with Hanning windowing.
%
%   sig = FM_SWEEP(f_start, f_end, fs, duration, amplitude, winprct) generates 
%   a frequency-modulated (FM) sweep signal, often used as a bat-like call. 
%   The frequency changes hyperbolically from a start frequency to an end 
%   frequency over a specified duration. The signal is then windowed with a 
%   Hanning window at its start and end to prevent spectral leakage.
%
%   INPUTS:
%   REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%   f_start     : Start frequency of the sweep. [1 x 1] (Hz)
%
%   f_end       : End frequency of the sweep. [1 x 1] (Hz)
%
%   fs          : Sampling frequency. [1 x 1] (Hz)
%
%   duration    : Duration of the sweep. [1 x 1] (ms)
%
%   amplitude   : Amplitude of the generated signal. [1 x 1]
%
%   winprct     : Percentage of the signal duration to be covered by the 
%                 Hanning window at the start and end of the signal. [1 x 1] (%)
%
%   OUTPUTS:
%   REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%   sig         : The generated FM sweep signal vector. [nSamples x 1]
%
%   NOTES:
%   - The frequency modulation is linear with respect to the period (1/f).
%   - The `duration` input is in milliseconds and is converted to seconds internally.
%   - The total length of the Hanning window is `2*winprct/100` of the signal length.

    % The time scale is in milliseconds, convert to seconds
    ms = 10^-3; 
    duration = duration * ms; 
    
    % Generate time vector
    t = 0:1/fs:duration; 
    
    % Generate the frequency modulation vector (linear with the period)
    ft = 1./(1/f_start + t * (1/f_end - 1/f_start) / duration); 
    
    % Generate the FM sweep signal
    sig = amplitude * (sin(2*pi*(duration/(1/f_end-1/f_start)) * (log(1/f_start+t*(1/f_end-1/f_start)/duration) - log(1/f_start))));
    
    % Apply Hanning window to the start and end of the signal
    length_win = round(length(sig)*2*winprct/100);
    window_short = hanning(length_win);
    window_on = window_short(1:ceil(length_win/2));
    window_off = window_short(ceil(length_win/2) + 1 : end);
    window = ones(1,length(sig));
    window(1:length(window_on)) = window_on;
    window(end-length(window_off) + 1 : end) = window_off;
    
    sig = sig .* window; 
end

function [mat_out] = normLog(mat_in,threshDB)
%NORMLOG Normalizes a matrix and converts it to a logarithmic (dB) scale.
%
%   [mat_out] = NORMLOG(mat_in, threshDB) normalizes the input matrix `mat_in` 
%   to its global maximum, clips negative values to zero, and then converts 
%   the result to a logarithmic scale in decibels (dB), applying a threshold 
%   to prevent log(0) errors.
%
%   By Cosys-Lab, University of Antwerp
%   Contributors: Jan Steckel
%
%   INPUTS:
%   REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%   mat_in      : The input matrix or array of any dimension.
%
%   threshDB    : A threshold value in decibels (dB). Values below this 
%                 threshold (relative to the maximum) will be clamped to 
%                 this value in the output. [1 x 1] (dB)
%
%   OUTPUTS:
%   REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%   mat_out     : The normalized, thresholded, and log-scaled output matrix.
%                 Dimensions are the same as `mat_in`.
%
%   NOTES:
%   - The function normalizes the input matrix by dividing by its global maximum value.
%   - The `threshDB` value is converted to a linear scale and added to the 
%     matrix before the `log10` operation to handle values close to zero.
%   - Negative values in the input matrix are clipped to zero before log-scaling.
%
    
    thresh = 10^(threshDB/20);
    mat_out = mat_in / max(max(max(max(mat_in))));
    mat_out( mat_out < 0 ) = 0;
    mat_out = 20*log10( mat_out + thresh);
end
##### SOURCE END #####
-->
</body>
</html>
