<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>example</title>
<meta name="generator" content="MATLAB 24.2">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-09-29">
<meta name="DC.source" content="example.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<h2>Contents</h2>
<div>
<ul>
<li>
<a href="#1">Setup scene and sensor</a>
</li>
<li>
<a href="#2">Setup Imaging</a>
</li>
<li>
<a href="#3">Generate microphone data</a>
</li>
<li>
<a href="#4">Run only DAS</a>
</li>
<li>
<a href="#5">Run full image calculation</a>
</li>
<li>
<a href="#6">Plot results</a>
</li>
<li>
<a href="#7">Helper functions</a>
</li>
</ul>
</div>
<h2 id="1">Setup scene and sensor</h2>
<pre class="codeinput">structScene = struct();
structScene.targetAzimuth = [0  -45  45  20  -20  70];
structScene.targetElevation = [0  0    0   0   0    0];
structScene.targetRange    = [2  1.5  1.8 2.5 2.5  3.0];
structScene.targetStrength = [1  1    1   1   1    1  ];
structScene.speedOfSound = 343;

structSensor = struct();
structSensor.sampleRate = 450e3;
structSensor.emissionSignal = fm_sweep(80e3, 20e3, structSensor.sampleRate, 2, 1, 10);
structSensor.coordinatesEmitter = [0 0 0.05];
structSensor.numSamplesSensor = 15000;
structSensor.coordinatesMicrophones = [0 -0.0384 0.0151; 0 -0.0232 0.0101; 0 -0.0121 0.0164; 0 -0.0046 0.0153; <span class="keyword">...</span>
                                       0 -0.0367 0.0054; 0 -0.0144 0.0061; 0 0.0054 0.0011; 0 0.0273 -0.0027; <span class="keyword">...</span>
                                       0 -0.0387 0.0001; 0 -0.0281 0.0002; 0 -0.0094 -0.0013; 0 -0.0060 -0.0000; <span class="keyword">...</span>
                                       0 -0.0357 -0.0117; 0 -0.0318 -0.0112; 0 -0.0286 -0.0166; 0 0.0029 -0.0086; <span class="keyword">...</span>
                                       0 -0.0011 0.0178; 0 0.0067 0.0115; 0 0.0103 0.0144; 0 0.0172 0.0140; <span class="keyword">...</span>
                                       0 0.0384 0.0022; 0 0.0283 0.0162; 0 0.0354 0.0125; 0 0.0373 0.0150; <span class="keyword">...</span>
                                       0 -0.0084 -0.0047; 0 0.0107 -0.0111; 0 0.0189 -0.0166; 0 0.0363 -0.0101; <span class="keyword">...</span>
                                       0 0.0057 -0.0224; 0 -0.0036 -0.0223; 0 0.0315 -0.0161; 0 0.0083 -0.0178];
</pre>
<h2 id="2">Setup Imaging</h2>
<pre class="codeinput">    structImage = struct();
    structImage.directionsAzimuth = -90:2:90;
    structImage.directionsElevation = zeros(size( structImage.directionsAzimuth));
    structImage.numDirections = length(structImage.directionsAzimuth);
    structImage.lowpassFreq = 5e3;
    structImage.doEnvelope = 1;
    structImage.doThresholdAtZero = 1;
    structImage.decimationFactor = 10;
    structImage.matchedFilterMethod = <span class="string">'Normal'</span>;
    structImage.matchedFilterFreq = [20e3 80e3];
    structImage.doMatchedFilter = 1;
</pre>
<h2 id="3">Generate microphone data</h2>
<pre class="codeinput">    dataMicrophones = simulateMicrophoneData(structScene, structSensor);
    dataMicrophones = dataMicrophones + 0.1 * randn(size(dataMicrophones));
</pre>
<h2 id="4">Run only DAS</h2>
<pre class="codeinput">    structImageDAS = structImage;
    structImageDAS.methodImaging = <span class="string">'DAS'</span>;
    structImageDAS.coherenceType = <span class="string">'none'</span>;
    structImageDAS.methodProcessing = <span class="string">'mexcpu'</span>;
    imageDAS = calculateAcousticImage(dataMicrophones, structSensor, structImageDAS);

    maxRange = structSensor.numSamplesSensor / structSensor.sampleRate * 343 / 2;
    rangeVector = linspace( 0, maxRange, size( imageDAS, 1 ) );

    dbCut = -80;
    imageDASLog = normLog( imageDAS, dbCut );

    figure();
    imagesc( structImage.directionsAzimuth, rangeVector, imageDASLog )
    xlabel( <span class="string">'Azimuth (&deg;)'</span> )
    ylabel( <span class="string">'Range (m)'</span>)
    set( gca, <span class="string">'ydir'</span>, <span class="string">'normal'</span> )
    title( <span class="string">'DAS'</span> )
    colorbar
    caxis( [ dbCut 0 ] )
</pre>
<img vspace="5" hspace="5" src="example_01.png" alt=""> <h2 id="5">Run full image calculation</h2>
<pre class="codeinput">    processingMethod = <span class="string">'mexcpu'</span>;

    tic
    <span class="comment">% --- DAS ---</span>
    structImageDAS = structImage;
    structImageDAS.methodImaging = <span class="string">'DAS'</span>;
    structImageDAS.coherenceType = <span class="string">'none'</span>;
    structImageDAS.methodProcessing = processingMethod;
    imageDAS = calculateAcousticImage(dataMicrophones, structSensor, structImageDAS);

    <span class="comment">% --- DAS-CF ---</span>
    structImageDASCF = structImage;
    structImageDASCF.methodImaging = <span class="string">'DAS'</span>;
    structImageDASCF.coherenceType = <span class="string">'CF'</span>;
    structImageDASCF.methodProcessing = processingMethod;
    imageDASCF = calculateAcousticImage(dataMicrophones, structSensor, structImageDASCF);

    <span class="comment">% --- DMAS ---</span>
    structImageDMAS = structImage;
    structImageDMAS.methodImaging = <span class="string">'DMAS'</span>;
    structImageDMAS.coherenceType = <span class="string">'none'</span>;
    structImageDMAS.methodProcessing = processingMethod;
    imageDMAS = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS);

    <span class="comment">% --- DMAS-CF ---</span>
    structImageDMASCF = structImage;
    structImageDMASCF.methodImaging = <span class="string">'DMAS'</span>;
    structImageDMASCF.coherenceType = <span class="string">'CF'</span>;
    structImageDMASCF.methodProcessing = processingMethod;
    imageDMASCF = calculateAcousticImage(dataMicrophones, structSensor, structImageDMASCF);

    <span class="comment">% --- DMAS3 ---</span>
    structImageDMAS3 = structImage;
    structImageDMAS3.methodImaging = <span class="string">'DMAS3'</span>;
    structImageDMAS3.coherenceType = <span class="string">'none'</span>;
    structImageDMAS3.methodProcessing = processingMethod;
    imageDMAS3 = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS3);

    <span class="comment">% --- DMAS3-CF  ---</span>
    structImageDMAS3CF = structImage;
    structImageDMAS3CF.methodImaging = <span class="string">'DMAS3'</span>;
    structImageDMAS3CF.coherenceType = <span class="string">'CF'</span>;
    structImageDMAS3CF.methodProcessing = processingMethod;
    imageDMAS3CF = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS3CF);

    <span class="comment">% --- DMAS4 ---</span>
    structImageDMAS4 = structImage;
    structImageDMAS4.methodImaging = <span class="string">'DMAS4'</span>;
    structImageDMAS4.coherenceType = <span class="string">'none'</span>;
    structImageDMAS4.methodProcessing = processingMethod;
    imageDMAS4 = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS4);

    <span class="comment">% --- DMAS4-CF  ---</span>
    structImageDMAS4CF = structImage;
    structImageDMAS4CF.methodImaging = <span class="string">'DMAS4'</span>;
    structImageDMAS4CF.coherenceType = <span class="string">'CF'</span>;
    structImageDMAS4CF.methodProcessing = processingMethod;
    imageDMAS4CF = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS4CF);

    <span class="comment">% --- DMAS5 ---</span>
    structImageDMAS5 = structImage;
    structImageDMAS5.methodImaging = <span class="string">'DMAS5'</span>;
    structImageDMAS5.coherenceType = <span class="string">'none'</span>;
    structImageDMAS5.methodProcessing = processingMethod;
    imageDMAS5 = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS5);

    <span class="comment">% --- DMAS5-CF ---</span>
    structImageDMAS5CF = structImage;
    structImageDMAS5CF.methodImaging = <span class="string">'DMAS5'</span>;
    structImageDMAS5CF.coherenceType = <span class="string">'CF'</span>;
    structImageDMAS5CF.methodProcessing = processingMethod;
    imageDMAS5CF = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS5CF);
    toc
</pre>
<pre class="codeoutput">Elapsed time is 33.536025 seconds.
</pre>
<h2 id="6">Plot results</h2>
<pre class="codeinput">    maxRange = structSensor.numSamplesSensor / structSensor.sampleRate * 343 / 2;
    rangeVector = linspace( 0, maxRange, size( imageDAS, 1 ) );

    dbCut = -80;
    imageDASLog = normLog( imageDAS, dbCut );
    imageDASCFLog = normLog( imageDASCF, dbCut );
    imageDMASLog = normLog( imageDMAS, dbCut );
    imageDMASCFLog = normLog( imageDMASCF, dbCut );
    imageDMAS3Log = normLog( imageDMAS3, dbCut );
    imageDMAS3CFLog = normLog( imageDMAS3CF, dbCut );
    imageDMAS4Log = normLog( imageDMAS4, dbCut );
    imageDMAS4CFLog = normLog( imageDMAS4CF, dbCut );
    imageDMAS5Log = normLog( imageDMAS5, dbCut );
    imageDMAS5CFLog = normLog( imageDMAS5CF, dbCut );

    figure();
    set(gcf, <span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'outerposition'</span>,[0 0 0.75 0.75]);
        tiledlayout( 2,5,<span class="string">'TileSpacing'</span>,<span class="string">'tight'</span>,<span class="string">'TileIndexing'</span>,<span class="string">'columnmajor'</span> )
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDASLog )
            xlabel( <span class="string">'Azimuth (&deg;)'</span> )
            ylabel( <span class="string">'Range (m)'</span>)
            set( gca, <span class="string">'ydir'</span>, <span class="string">'normal'</span> )
            title( <span class="string">'DAS'</span> )
            colorbar
           caxis( [ dbCut 0 ] )
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDASCFLog )
            xlabel( <span class="string">'Azimuth (&deg;)'</span> )
            ylabel( <span class="string">'Range (m)'</span>)
            set( gca, <span class="string">'ydir'</span>, <span class="string">'normal'</span> )
            title( <span class="string">'DAS-CF'</span> )
            colorbar
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMASLog )
            xlabel( <span class="string">'Azimuth (&deg;)'</span> )
            ylabel( <span class="string">'Range (m)'</span>)
            set( gca, <span class="string">'ydir'</span>, <span class="string">'normal'</span> )
            title( <span class="string">'DMAS1'</span> )
            colorbar
           caxis( [ dbCut 0 ] )
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMASCFLog )
            xlabel( <span class="string">'Azimuth (&deg;)'</span> )
            ylabel( <span class="string">'Range (m)'</span>)
            set( gca, <span class="string">'ydir'</span>, <span class="string">'normal'</span> )
            title( <span class="string">'DMAS1-CF'</span> )
            colorbar
           caxis( [ dbCut 0 ] )
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMAS3Log )
            xlabel( <span class="string">'Azimuth (&deg;)'</span> )
            ylabel( <span class="string">'Range (m)'</span>)
            set( gca, <span class="string">'ydir'</span>, <span class="string">'normal'</span> )
            title( <span class="string">'DMAS3'</span> )
            colorbar
           caxis( [ dbCut 0 ] )
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMAS3CFLog )
            xlabel( <span class="string">'Azimuth (&deg;)'</span> )
            ylabel( <span class="string">'Range (m)'</span>)
            set( gca, <span class="string">'ydir'</span>, <span class="string">'normal'</span> )
            title( <span class="string">'DMAS3-CF'</span> )
            colorbar
           caxis( [ dbCut 0 ] )
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMAS4Log )
            xlabel( <span class="string">'Azimuth (&deg;)'</span> )
            ylabel( <span class="string">'Range (m)'</span>)
            set( gca, <span class="string">'ydir'</span>, <span class="string">'normal'</span> )
            title( <span class="string">'DMAS4'</span> )
            colorbar
            caxis( [ dbCut 0 ] )
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMAS4CFLog )
            xlabel( <span class="string">'Azimuth (&deg;)'</span> )
            ylabel( <span class="string">'Range (m)'</span>)
            set( gca, <span class="string">'ydir'</span>, <span class="string">'normal'</span> )
            title( <span class="string">'DMAS4-CF'</span> )
            colorbar
            caxis( [ dbCut 0 ] )
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMAS5Log )
            xlabel( <span class="string">'Azimuth (&deg;)'</span> )
            ylabel( <span class="string">'Range (m)'</span>)
            set( gca, <span class="string">'ydir'</span>, <span class="string">'normal'</span> )
            title( <span class="string">'DMAS5'</span> )
            colorbar
            caxis( [ dbCut 0 ] )
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMAS5CFLog )
            xlabel( <span class="string">'Azimuth (&deg;)'</span> )
            ylabel( <span class="string">'Range (m)'</span>)
            set( gca, <span class="string">'ydir'</span>, <span class="string">'normal'</span> )
            title( <span class="string">'DMAS5-CF'</span> )
            colorbar
            caxis( [ dbCut 0 ] )
</pre>
<img vspace="5" hspace="5" src="example_02.png" alt=""> <h2 id="7">Helper functions</h2>
<pre class="codeinput">
<span class="keyword">function</span> dataMicrophonesOut = simulateMicrophoneData( structScene, structSensor )
<span class="comment">%SIMULATEMICROPHONEDATA Simulates microphone data from point targets in a scene.</span>
<span class="comment">%</span>
<span class="comment">%   dataMicrophonesOut = SIMULATEMICROPHONEDATA(structScene, structSensor)</span>
<span class="comment">%   generates a time-domain signal for each microphone by simulating the</span>
<span class="comment">%   reflection of an emitted signal from a set of point targets. The simulation</span>
<span class="comment">%   accounts for the time-of-flight from the emitter to each target and then</span>
<span class="comment">%   to each microphone.</span>
<span class="comment">%</span>
<span class="comment">%   By Cosys-Lab, University of Antwerp</span>
<span class="comment">%   Contributors: Jan Steckel</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS:</span>
<span class="comment">%   -----------------------------------------------------------------------</span>
<span class="comment">%   structScene      : Structure containing scene and target properties. (Mandatory)</span>
<span class="comment">%       .targetAzimuth      : Azimuth angles of point targets. [numTargets x 1] (deg)</span>
<span class="comment">%       .targetElevation    : Elevation angles of point targets. [numTargets x 1] (deg)</span>
<span class="comment">%       .targetRange        : Range (distance) to each point target. [numTargets x 1] (m)</span>
<span class="comment">%       .speedOfSound       : Speed of sound in the medium. [1 x 1] (m/s)</span>
<span class="comment">%       .targetStrength     : Amplitude of the reflection from each target. [numTargets x 1]</span>
<span class="comment">%</span>
<span class="comment">%   structSensor     : Structure containing sensor array setup and signal characteristics. (Mandatory)</span>
<span class="comment">%       .coordinatesEmitter     : Position of the sound source. [1 x 3] (m)</span>
<span class="comment">%       .coordinatesMicrophones : Positions of the microphone array elements. [numMics x 3] (m)</span>
<span class="comment">%       .numSamplesSensor       : Total number of samples to simulate. [1 x 1]</span>
<span class="comment">%       .sampleRate             : ADC sampling frequency. [1 x 1] (Hz)</span>
<span class="comment">%       .emissionSignal         : The transmitted signal. [numSamplesBase x 1]</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS:</span>
<span class="comment">%   -----------------------------------------------------------------------</span>
<span class="comment">%   dataMicrophonesOut : The simulated microphone data.</span>
<span class="comment">%                        Dimensions: [numSamplesSensor x numMics].</span>
<span class="comment">%</span>
<span class="comment">%   NOTES:</span>
<span class="comment">%   - The function models reflections as simple time-of-flight delays and amplitude scaling.</span>
<span class="comment">%   - The final output is the convolution of the time-of-flight impulse response with the emission signal.</span>

    [ pointsX, pointsY, pointsZ ] = sph2cart( deg2rad( structScene.targetAzimuth ), deg2rad( structScene.targetElevation ), structScene.targetRange  );
    targetsCartesian = [ pointsX ;pointsY ;pointsZ ]';

    numTargets = length( structScene.targetAzimuth );
    numChannels = size( structSensor.coordinatesMicrophones, 1 );

    dataMicrophones = zeros( structSensor.numSamplesSensor, numChannels );
    <span class="keyword">for</span> cntTarget = 1 : numTargets
        rangesToTarget = sqrt( sum(( structSensor.coordinatesEmitter - targetsCartesian( cntTarget, : ) ).^2, 2 ) );
        rangesFromTarget = sqrt( sum(( structSensor.coordinatesMicrophones - targetsCartesian( cntTarget, : ) ).^2, 2 ) );
        totalRanges = rangesToTarget + rangesFromTarget;
        totalTimeInSamples = round( totalRanges / structScene.speedOfSound *  structSensor.sampleRate );

        <span class="comment">% rows = totalTimeInSamples(:);        % arrival times</span>
        <span class="comment">% cols = (1:numChannels)';             % channel indices</span>
        <span class="comment">% idx  = sub2ind(size(dataMicrophones), rows, cols);</span>

        <span class="keyword">for</span> cntChannel = 1 : numChannels
            curSample = totalTimeInSamples( cntChannel );
            dataMicrophones( curSample, cntChannel ) = dataMicrophones( curSample, cntChannel ) + structScene.targetStrength( cntTarget );
        <span class="keyword">end</span>
    <span class="keyword">end</span>
    dataMicrophonesOut = zeros( size( dataMicrophones ) );
    <span class="keyword">for</span> cntChannel = 1 : numChannels
        dataMicrophonesOut( :, cntChannel ) = dataMicrophones( :, cntChannel ) + conv( dataMicrophones( :, cntChannel ), structSensor.emissionSignal, <span class="string">'same'</span> );
    <span class="keyword">end</span>

<span class="keyword">end</span>

<span class="keyword">function</span> sig=fm_sweep(f_start,f_end,fs,duration, amplitude, winprct)
<span class="comment">%FM_SWEEP Generates a hyperbolic FM sweep signal with Hanning windowing.</span>
<span class="comment">%</span>
<span class="comment">%   sig = FM_SWEEP(f_start, f_end, fs, duration, amplitude, winprct) generates</span>
<span class="comment">%   a frequency-modulated (FM) sweep signal, often used as a bat-like call.</span>
<span class="comment">%   The frequency changes hyperbolically from a start frequency to an end</span>
<span class="comment">%   frequency over a specified duration. The signal is then windowed with a</span>
<span class="comment">%   Hanning window at its start and end to prevent spectral leakage.</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS:</span>
<span class="comment">%   -----------------------------------------------------------------------</span>
<span class="comment">%   f_start     : Start frequency of the sweep. [1 x 1] (Hz)</span>
<span class="comment">%</span>
<span class="comment">%   f_end       : End frequency of the sweep. [1 x 1] (Hz)</span>
<span class="comment">%</span>
<span class="comment">%   fs          : Sampling frequency. [1 x 1] (Hz)</span>
<span class="comment">%</span>
<span class="comment">%   duration    : Duration of the sweep. [1 x 1] (ms)</span>
<span class="comment">%</span>
<span class="comment">%   amplitude   : Amplitude of the generated signal. [1 x 1]</span>
<span class="comment">%</span>
<span class="comment">%   winprct     : Percentage of the signal duration to be covered by the</span>
<span class="comment">%                 Hanning window at the start and end of the signal. [1 x 1] (%)</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS:</span>
<span class="comment">%   -----------------------------------------------------------------------</span>
<span class="comment">%   sig         : The generated FM sweep signal vector. [nSamples x 1]</span>
<span class="comment">%</span>
<span class="comment">%   NOTES:</span>
<span class="comment">%   - The frequency modulation is linear with respect to the period (1/f).</span>
<span class="comment">%   - The `duration` input is in milliseconds and is converted to seconds internally.</span>
<span class="comment">%   - The total length of the Hanning window is `2*winprct/100` of the signal length.</span>

    <span class="comment">% The time scale is in milliseconds, convert to seconds</span>
    ms = 10^-3;
    duration = duration * ms;

    <span class="comment">% Generate time vector</span>
    t = 0:1/fs:duration;

    <span class="comment">% Generate the frequency modulation vector (linear with the period)</span>
    ft = 1./(1/f_start + t * (1/f_end - 1/f_start) / duration);

    <span class="comment">% Generate the FM sweep signal</span>
    sig = amplitude * (sin(2*pi*(duration/(1/f_end-1/f_start)) * (log(1/f_start+t*(1/f_end-1/f_start)/duration) - log(1/f_start))));

    <span class="comment">% Apply Hanning window to the start and end of the signal</span>
    length_win = round(length(sig)*2*winprct/100);
    window_short = hanning(length_win);
    window_on = window_short(1:ceil(length_win/2));
    window_off = window_short(ceil(length_win/2) + 1 : end);
    window = ones(1,length(sig));
    window(1:length(window_on)) = window_on;
    window(end-length(window_off) + 1 : end) = window_off;

    sig = sig .* window;
<span class="keyword">end</span>

<span class="keyword">function</span> [mat_out] = normLog(mat_in,threshDB)
<span class="comment">%NORMLOG Normalizes a matrix and converts it to a logarithmic (dB) scale.</span>
<span class="comment">%</span>
<span class="comment">%   [mat_out] = NORMLOG(mat_in, threshDB) normalizes the input matrix `mat_in`</span>
<span class="comment">%   to its global maximum, clips negative values to zero, and then converts</span>
<span class="comment">%   the result to a logarithmic scale in decibels (dB), applying a threshold</span>
<span class="comment">%   to prevent log(0) errors.</span>
<span class="comment">%</span>
<span class="comment">%   By Cosys-Lab, University of Antwerp</span>
<span class="comment">%   Contributors: Jan Steckel</span>
<span class="comment">%</span>
<span class="comment">%   INPUTS:</span>
<span class="comment">%   -----------------------------------------------------------------------</span>
<span class="comment">%   mat_in      : The input matrix or array of any dimension.</span>
<span class="comment">%</span>
<span class="comment">%   threshDB    : A threshold value in decibels (dB). Values below this</span>
<span class="comment">%                 threshold (relative to the maximum) will be clamped to</span>
<span class="comment">%                 this value in the output. [1 x 1] (dB)</span>
<span class="comment">%</span>
<span class="comment">%   OUTPUTS:</span>
<span class="comment">%   -----------------------------------------------------------------------</span>
<span class="comment">%   mat_out     : The normalized, thresholded, and log-scaled output matrix.</span>
<span class="comment">%                 Dimensions are the same as `mat_in`.</span>
<span class="comment">%</span>
<span class="comment">%   NOTES:</span>
<span class="comment">%   - The function normalizes the input matrix by dividing by its global maximum value.</span>
<span class="comment">%   - The `threshDB` value is converted to a linear scale and added to the</span>
<span class="comment">%     matrix before the `log10` operation to handle values close to zero.</span>
<span class="comment">%   - Negative values in the input matrix are clipped to zero before log-scaling.</span>
<span class="comment">%</span>

    thresh = 10^(threshDB/20);
    mat_out = mat_in / max(max(max(max(mat_in))));
    mat_out( mat_out &lt; 0 ) = 0;
    mat_out = 20*log10( mat_out + thresh);
<span class="keyword">end</span>
</pre>
<p class="footer">
<br>
<a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2024b</a>
<br>
</p>
</div>
<!--
##### SOURCE BEGIN #####
%% Setup scene and sensor

structScene = struct();
structScene.targetAzimuth = [0  -45  45  20  -20  70];
structScene.targetElevation = [0  0    0   0   0    0];
structScene.targetRange    = [2  1.5  1.8 2.5 2.5  3.0];
structScene.targetStrength = [1  1    1   1   1    1  ];
structScene.speedOfSound = 343;

structSensor = struct();
structSensor.sampleRate = 450e3;
structSensor.emissionSignal = fm_sweep(80e3, 20e3, structSensor.sampleRate, 2, 1, 10);
structSensor.coordinatesEmitter = [0 0 0.05];
structSensor.numSamplesSensor = 15000;
structSensor.coordinatesMicrophones = [0 -0.0384 0.0151; 0 -0.0232 0.0101; 0 -0.0121 0.0164; 0 -0.0046 0.0153; ...
                                       0 -0.0367 0.0054; 0 -0.0144 0.0061; 0 0.0054 0.0011; 0 0.0273 -0.0027; ...
                                       0 -0.0387 0.0001; 0 -0.0281 0.0002; 0 -0.0094 -0.0013; 0 -0.0060 -0.0000; ...
                                       0 -0.0357 -0.0117; 0 -0.0318 -0.0112; 0 -0.0286 -0.0166; 0 0.0029 -0.0086; ...
                                       0 -0.0011 0.0178; 0 0.0067 0.0115; 0 0.0103 0.0144; 0 0.0172 0.0140; ...
                                       0 0.0384 0.0022; 0 0.0283 0.0162; 0 0.0354 0.0125; 0 0.0373 0.0150; ...
                                       0 -0.0084 -0.0047; 0 0.0107 -0.0111; 0 0.0189 -0.0166; 0 0.0363 -0.0101; ...
                                       0 0.0057 -0.0224; 0 -0.0036 -0.0223; 0 0.0315 -0.0161; 0 0.0083 -0.0178];
    
%% Setup Imaging

    structImage = struct();
    structImage.directionsAzimuth = -90:2:90;
    structImage.directionsElevation = zeros(size( structImage.directionsAzimuth));
    structImage.numDirections = length(structImage.directionsAzimuth);
    structImage.lowpassFreq = 5e3;
    structImage.doEnvelope = 1;
    structImage.doThresholdAtZero = 1;
    structImage.decimationFactor = 10;
    structImage.matchedFilterMethod = 'Normal';
    structImage.matchedFilterFreq = [20e3 80e3];
    structImage.doMatchedFilter = 1;
    
%% Generate microphone data

    dataMicrophones = simulateMicrophoneData(structScene, structSensor);
    dataMicrophones = dataMicrophones + 0.1 * randn(size(dataMicrophones));

%% Run only DAS

    structImageDAS = structImage;
    structImageDAS.methodImaging = 'DAS';
    structImageDAS.coherenceType = 'none';
    structImageDAS.methodProcessing = 'mexcpu'; 
    imageDAS = calculateAcousticImage(dataMicrophones, structSensor, structImageDAS);

    maxRange = structSensor.numSamplesSensor / structSensor.sampleRate * 343 / 2;    
    rangeVector = linspace( 0, maxRange, size( imageDAS, 1 ) );

    dbCut = -80;
    imageDASLog = normLog( imageDAS, dbCut );

    figure(); 
    imagesc( structImage.directionsAzimuth, rangeVector, imageDASLog )
    xlabel( 'Azimuth (°)' )
    ylabel( 'Range (m)')
    set( gca, 'ydir', 'normal' )
    title( 'DAS' )
    colorbar
    caxis( [ dbCut 0 ] )  

%% Run full image calculation

    processingMethod = 'mexcpu'; 
    
    tic
    % REPLACE_WITH_DASH_DASH- DAS REPLACE_WITH_DASH_DASH-
    structImageDAS = structImage;
    structImageDAS.methodImaging = 'DAS';
    structImageDAS.coherenceType = 'none';
    structImageDAS.methodProcessing = processingMethod; 
    imageDAS = calculateAcousticImage(dataMicrophones, structSensor, structImageDAS);
    
    % REPLACE_WITH_DASH_DASH- DAS-CF REPLACE_WITH_DASH_DASH-
    structImageDASCF = structImage;
    structImageDASCF.methodImaging = 'DAS';
    structImageDASCF.coherenceType = 'CF';
    structImageDASCF.methodProcessing = processingMethod; 
    imageDASCF = calculateAcousticImage(dataMicrophones, structSensor, structImageDASCF);

    % REPLACE_WITH_DASH_DASH- DMAS REPLACE_WITH_DASH_DASH-
    structImageDMAS = structImage;
    structImageDMAS.methodImaging = 'DMAS';
    structImageDMAS.coherenceType = 'none';
    structImageDMAS.methodProcessing = processingMethod; 
    imageDMAS = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS);

    % REPLACE_WITH_DASH_DASH- DMAS-CF REPLACE_WITH_DASH_DASH-
    structImageDMASCF = structImage;
    structImageDMASCF.methodImaging = 'DMAS';
    structImageDMASCF.coherenceType = 'CF';
    structImageDMASCF.methodProcessing = processingMethod;
    imageDMASCF = calculateAcousticImage(dataMicrophones, structSensor, structImageDMASCF);
    
    % REPLACE_WITH_DASH_DASH- DMAS3 REPLACE_WITH_DASH_DASH-
    structImageDMAS3 = structImage;
    structImageDMAS3.methodImaging = 'DMAS3';
    structImageDMAS3.coherenceType = 'none';
    structImageDMAS3.methodProcessing = processingMethod; 
    imageDMAS3 = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS3);
    
    % REPLACE_WITH_DASH_DASH- DMAS3-CF  REPLACE_WITH_DASH_DASH-
    structImageDMAS3CF = structImage;
    structImageDMAS3CF.methodImaging = 'DMAS3';
    structImageDMAS3CF.coherenceType = 'CF';
    structImageDMAS3CF.methodProcessing = processingMethod; 
    imageDMAS3CF = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS3CF);

    % REPLACE_WITH_DASH_DASH- DMAS4 REPLACE_WITH_DASH_DASH-
    structImageDMAS4 = structImage;
    structImageDMAS4.methodImaging = 'DMAS4';
    structImageDMAS4.coherenceType = 'none';
    structImageDMAS4.methodProcessing = processingMethod;
    imageDMAS4 = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS4);

    % REPLACE_WITH_DASH_DASH- DMAS4-CF  REPLACE_WITH_DASH_DASH-
    structImageDMAS4CF = structImage;
    structImageDMAS4CF.methodImaging = 'DMAS4';
    structImageDMAS4CF.coherenceType = 'CF';
    structImageDMAS4CF.methodProcessing = processingMethod; 
    imageDMAS4CF = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS4CF);
    
    % REPLACE_WITH_DASH_DASH- DMAS5 REPLACE_WITH_DASH_DASH-
    structImageDMAS5 = structImage;
    structImageDMAS5.methodImaging = 'DMAS5';
    structImageDMAS5.coherenceType = 'none';
    structImageDMAS5.methodProcessing = processingMethod; 
    imageDMAS5 = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS5);

    % REPLACE_WITH_DASH_DASH- DMAS5-CF REPLACE_WITH_DASH_DASH-
    structImageDMAS5CF = structImage;
    structImageDMAS5CF.methodImaging = 'DMAS5';
    structImageDMAS5CF.coherenceType = 'CF';
    structImageDMAS5CF.methodProcessing = processingMethod;
    imageDMAS5CF = calculateAcousticImage(dataMicrophones, structSensor, structImageDMAS5CF);
    toc
    
%% Plot results

    maxRange = structSensor.numSamplesSensor / structSensor.sampleRate * 343 / 2;    
    rangeVector = linspace( 0, maxRange, size( imageDAS, 1 ) );    

    dbCut = -80;
    imageDASLog = normLog( imageDAS, dbCut );
    imageDASCFLog = normLog( imageDASCF, dbCut );
    imageDMASLog = normLog( imageDMAS, dbCut );
    imageDMASCFLog = normLog( imageDMASCF, dbCut );
    imageDMAS3Log = normLog( imageDMAS3, dbCut );
    imageDMAS3CFLog = normLog( imageDMAS3CF, dbCut );
    imageDMAS4Log = normLog( imageDMAS4, dbCut );
    imageDMAS4CFLog = normLog( imageDMAS4CF, dbCut );
    imageDMAS5Log = normLog( imageDMAS5, dbCut );
    imageDMAS5CFLog = normLog( imageDMAS5CF, dbCut );

    figure(); 
    set(gcf, 'units','normalized','outerposition',[0 0 0.75 0.75]);
        tiledlayout( 2,5,'TileSpacing','tight','TileIndexing','columnmajor' )
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDASLog )
            xlabel( 'Azimuth (°)' )
            ylabel( 'Range (m)')
            set( gca, 'ydir', 'normal' )
            title( 'DAS' )
            colorbar
           caxis( [ dbCut 0 ] )            
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDASCFLog )
            xlabel( 'Azimuth (°)' )
            ylabel( 'Range (m)')
            set( gca, 'ydir', 'normal' )
            title( 'DAS-CF' )   
            colorbar
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMASLog )
            xlabel( 'Azimuth (°)' )
            ylabel( 'Range (m)')
            set( gca, 'ydir', 'normal' )
            title( 'DMAS1' )    
            colorbar
           caxis( [ dbCut 0 ] )            
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMASCFLog )
            xlabel( 'Azimuth (°)' )
            ylabel( 'Range (m)')
            set( gca, 'ydir', 'normal' )
            title( 'DMAS1-CF' ) 
            colorbar
           caxis( [ dbCut 0 ] )            
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMAS3Log )
            xlabel( 'Azimuth (°)' )
            ylabel( 'Range (m)')
            set( gca, 'ydir', 'normal' )
            title( 'DMAS3' )  
            colorbar
           caxis( [ dbCut 0 ] )            
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMAS3CFLog )
            xlabel( 'Azimuth (°)' )
            ylabel( 'Range (m)')
            set( gca, 'ydir', 'normal' )
            title( 'DMAS3-CF' )  
            colorbar
           caxis( [ dbCut 0 ] )            
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMAS4Log )
            xlabel( 'Azimuth (°)' )
            ylabel( 'Range (m)')
            set( gca, 'ydir', 'normal' )
            title( 'DMAS4' )   
            colorbar
            caxis( [ dbCut 0 ] )
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMAS4CFLog )
            xlabel( 'Azimuth (°)' )
            ylabel( 'Range (m)')
            set( gca, 'ydir', 'normal' )
            title( 'DMAS4-CF' )  
            colorbar
            caxis( [ dbCut 0 ] )
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMAS5Log )
            xlabel( 'Azimuth (°)' )
            ylabel( 'Range (m)')
            set( gca, 'ydir', 'normal' )
            title( 'DMAS5' )   
            colorbar
            caxis( [ dbCut 0 ] )
        nexttile()
            imagesc( structImage.directionsAzimuth, rangeVector, imageDMAS5CFLog )
            xlabel( 'Azimuth (°)' )
            ylabel( 'Range (m)')
            set( gca, 'ydir', 'normal' )
            title( 'DMAS5-CF' )  
            colorbar
            caxis( [ dbCut 0 ] )
            
%% Helper functions

function dataMicrophonesOut = simulateMicrophoneData( structScene, structSensor )
%SIMULATEMICROPHONEDATA Simulates microphone data from point targets in a scene.
%
%   dataMicrophonesOut = SIMULATEMICROPHONEDATA(structScene, structSensor) 
%   generates a time-domain signal for each microphone by simulating the 
%   reflection of an emitted signal from a set of point targets. The simulation 
%   accounts for the time-of-flight from the emitter to each target and then 
%   to each microphone.
%
%   By Cosys-Lab, University of Antwerp
%   Contributors: Jan Steckel
%
%   INPUTS:
%   REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%   structScene      : Structure containing scene and target properties. (Mandatory)
%       .targetAzimuth      : Azimuth angles of point targets. [numTargets x 1] (deg)
%       .targetElevation    : Elevation angles of point targets. [numTargets x 1] (deg)
%       .targetRange        : Range (distance) to each point target. [numTargets x 1] (m)
%       .speedOfSound       : Speed of sound in the medium. [1 x 1] (m/s)
%       .targetStrength     : Amplitude of the reflection from each target. [numTargets x 1]
%
%   structSensor     : Structure containing sensor array setup and signal characteristics. (Mandatory)
%       .coordinatesEmitter     : Position of the sound source. [1 x 3] (m)
%       .coordinatesMicrophones : Positions of the microphone array elements. [numMics x 3] (m)
%       .numSamplesSensor       : Total number of samples to simulate. [1 x 1]
%       .sampleRate             : ADC sampling frequency. [1 x 1] (Hz)
%       .emissionSignal         : The transmitted signal. [numSamplesBase x 1]
%
%   OUTPUTS:
%   REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%   dataMicrophonesOut : The simulated microphone data.
%                        Dimensions: [numSamplesSensor x numMics].
%
%   NOTES:
%   - The function models reflections as simple time-of-flight delays and amplitude scaling.
%   - The final output is the convolution of the time-of-flight impulse response with the emission signal.
  
    [ pointsX, pointsY, pointsZ ] = sph2cart( deg2rad( structScene.targetAzimuth ), deg2rad( structScene.targetElevation ), structScene.targetRange  );
    targetsCartesian = [ pointsX ;pointsY ;pointsZ ]';
    
    numTargets = length( structScene.targetAzimuth );
    numChannels = size( structSensor.coordinatesMicrophones, 1 );
    
    dataMicrophones = zeros( structSensor.numSamplesSensor, numChannels );  
    for cntTarget = 1 : numTargets
        rangesToTarget = sqrt( sum(( structSensor.coordinatesEmitter - targetsCartesian( cntTarget, : ) ).^2, 2 ) );
        rangesFromTarget = sqrt( sum(( structSensor.coordinatesMicrophones - targetsCartesian( cntTarget, : ) ).^2, 2 ) );
        totalRanges = rangesToTarget + rangesFromTarget;
        totalTimeInSamples = round( totalRanges / structScene.speedOfSound *  structSensor.sampleRate );
    
        % rows = totalTimeInSamples(:);        % arrival times
        % cols = (1:numChannels)';             % channel indices
        % idx  = sub2ind(size(dataMicrophones), rows, cols);
    
        for cntChannel = 1 : numChannels
            curSample = totalTimeInSamples( cntChannel );
            dataMicrophones( curSample, cntChannel ) = dataMicrophones( curSample, cntChannel ) + structScene.targetStrength( cntTarget );
        end
    end
    dataMicrophonesOut = zeros( size( dataMicrophones ) );
    for cntChannel = 1 : numChannels
        dataMicrophonesOut( :, cntChannel ) = dataMicrophones( :, cntChannel ) + conv( dataMicrophones( :, cntChannel ), structSensor.emissionSignal, 'same' );
    end

end

function sig=fm_sweep(f_start,f_end,fs,duration, amplitude, winprct)
%FM_SWEEP Generates a hyperbolic FM sweep signal with Hanning windowing.
%
%   sig = FM_SWEEP(f_start, f_end, fs, duration, amplitude, winprct) generates 
%   a frequency-modulated (FM) sweep signal, often used as a bat-like call. 
%   The frequency changes hyperbolically from a start frequency to an end 
%   frequency over a specified duration. The signal is then windowed with a 
%   Hanning window at its start and end to prevent spectral leakage.
%
%   INPUTS:
%   REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%   f_start     : Start frequency of the sweep. [1 x 1] (Hz)
%
%   f_end       : End frequency of the sweep. [1 x 1] (Hz)
%
%   fs          : Sampling frequency. [1 x 1] (Hz)
%
%   duration    : Duration of the sweep. [1 x 1] (ms)
%
%   amplitude   : Amplitude of the generated signal. [1 x 1]
%
%   winprct     : Percentage of the signal duration to be covered by the 
%                 Hanning window at the start and end of the signal. [1 x 1] (%)
%
%   OUTPUTS:
%   REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%   sig         : The generated FM sweep signal vector. [nSamples x 1]
%
%   NOTES:
%   - The frequency modulation is linear with respect to the period (1/f).
%   - The `duration` input is in milliseconds and is converted to seconds internally.
%   - The total length of the Hanning window is `2*winprct/100` of the signal length.

    % The time scale is in milliseconds, convert to seconds
    ms = 10^-3; 
    duration = duration * ms; 
    
    % Generate time vector
    t = 0:1/fs:duration; 
    
    % Generate the frequency modulation vector (linear with the period)
    ft = 1./(1/f_start + t * (1/f_end - 1/f_start) / duration); 
    
    % Generate the FM sweep signal
    sig = amplitude * (sin(2*pi*(duration/(1/f_end-1/f_start)) * (log(1/f_start+t*(1/f_end-1/f_start)/duration) - log(1/f_start))));
    
    % Apply Hanning window to the start and end of the signal
    length_win = round(length(sig)*2*winprct/100);
    window_short = hanning(length_win);
    window_on = window_short(1:ceil(length_win/2));
    window_off = window_short(ceil(length_win/2) + 1 : end);
    window = ones(1,length(sig));
    window(1:length(window_on)) = window_on;
    window(end-length(window_off) + 1 : end) = window_off;
    
    sig = sig .* window; 
end

function [mat_out] = normLog(mat_in,threshDB)
%NORMLOG Normalizes a matrix and converts it to a logarithmic (dB) scale.
%
%   [mat_out] = NORMLOG(mat_in, threshDB) normalizes the input matrix `mat_in` 
%   to its global maximum, clips negative values to zero, and then converts 
%   the result to a logarithmic scale in decibels (dB), applying a threshold 
%   to prevent log(0) errors.
%
%   By Cosys-Lab, University of Antwerp
%   Contributors: Jan Steckel
%
%   INPUTS:
%   REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%   mat_in      : The input matrix or array of any dimension.
%
%   threshDB    : A threshold value in decibels (dB). Values below this 
%                 threshold (relative to the maximum) will be clamped to 
%                 this value in the output. [1 x 1] (dB)
%
%   OUTPUTS:
%   REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
%   mat_out     : The normalized, thresholded, and log-scaled output matrix.
%                 Dimensions are the same as `mat_in`.
%
%   NOTES:
%   - The function normalizes the input matrix by dividing by its global maximum value.
%   - The `threshDB` value is converted to a linear scale and added to the 
%     matrix before the `log10` operation to handle values close to zero.
%   - Negative values in the input matrix are clipped to zero before log-scaling.
%
    
    thresh = 10^(threshDB/20);
    mat_out = mat_in / max(max(max(max(mat_in))));
    mat_out( mat_out < 0 ) = 0;
    mat_out = 20*log10( mat_out + thresh);
end
##### SOURCE END #####
-->
</body>
</html>
